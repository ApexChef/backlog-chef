import { Formatter, PBIReadinessAssessment, ReadinessAssessmentInput } from '../types';

/**
 * Azure DevOps Work Item formatter
 * Outputs in a format suitable for import into Azure DevOps
 */
export class DevOpsFormatter implements Formatter {
  format(pbi: PBIReadinessAssessment): string {
    const sections: string[] = [];

    // Work Item Header
    sections.push(`Work Item Type: Product Backlog Item`);
    sections.push(`ID: ${pbi.pbi_id}`);
    sections.push(`Title: ${pbi.title}`);
    sections.push(`State: ${this.mapStatusToState(pbi.readiness_status)}`);
    sections.push(`Priority: ${this.calculatePriority(pbi)}`);
    sections.push('');

    // Description
    sections.push(`## Description\n`);
    sections.push(`Readiness Status: ${pbi.readiness_status}`);
    sections.push(`Readiness Score: ${pbi.readiness_score}`);
    sections.push(`Sprint Readiness ETA: ${pbi.sprint_readiness_eta}`);
    sections.push('');

    // Acceptance Criteria
    sections.push(`## Acceptance Criteria\n`);

    const passedCount = Object.keys(pbi.definition_of_ready_checklist.passed || {}).length;
    const blockingCount = Object.keys(pbi.definition_of_ready_checklist.blocking_failures || {}).length;
    const warningCount = Object.keys(pbi.definition_of_ready_checklist.warnings || {}).length;

    sections.push(`✅ Passed Criteria: ${passedCount}`);
    sections.push(`❌ Blocking Issues: ${blockingCount}`);
    sections.push(`⚠️ Warnings: ${warningCount}`);
    sections.push('');

    // Blocking Issues
    if (pbi.definition_of_ready_checklist.blocking_failures &&
        Object.keys(pbi.definition_of_ready_checklist.blocking_failures).length > 0) {
      sections.push(`### Blocking Issues (Must Resolve)\n`);

      for (const [criterionId, evaluation] of Object.entries(pbi.definition_of_ready_checklist.blocking_failures)) {
        const name = this.formatCriterionName(criterionId);
        sections.push(`**${name}**`);

        if (evaluation.issues && evaluation.issues.length > 0) {
          for (const issue of evaluation.issues) {
            sections.push(`- ${issue}`);
          }
        }

        if (evaluation.action_required) {
          sections.push(`Action: ${evaluation.action_required}`);
        }
        sections.push('');
      }
    }

    // Tasks (from recommended actions)
    if (pbi.recommended_next_actions.immediate || pbi.recommended_next_actions.before_sprint) {
      sections.push(`## Tasks\n`);

      if (pbi.recommended_next_actions.immediate) {
        for (const action of pbi.recommended_next_actions.immediate) {
          sections.push(`- [ ] [${action.priority}] ${action.action}`);
          if (action.owner) {
            sections.push(`  Assigned To: ${action.owner}`);
          }
          if (action.estimated_time) {
            sections.push(`  Estimated Effort: ${action.estimated_time}`);
          }
        }
      }

      if (pbi.recommended_next_actions.before_sprint) {
        for (const action of pbi.recommended_next_actions.before_sprint) {
          sections.push(`- [ ] ${action.action}`);
          if (action.owner) {
            sections.push(`  Assigned To: ${action.owner}`);
          }
        }
      }
      sections.push('');
    }

    // Story Points / Effort
    if (pbi.estimation_guidance) {
      sections.push(`## Effort Estimate\n`);
      sections.push(`${pbi.estimation_guidance.recommended_estimate || 'Not estimated'}`);

      if (pbi.estimation_guidance.complexity_factors) {
        sections.push(`\nComplexity Factors:`);
        for (const factor of pbi.estimation_guidance.complexity_factors) {
          sections.push(`- ${factor}`);
        }
      }
      sections.push('');
    }

    // Tags
    const tags = this.generateTags(pbi);
    if (tags.length > 0) {
      sections.push(`## Tags\n`);
      sections.push(tags.join('; '));
      sections.push('');
    }

    // Discussion / Notes
    sections.push(`## Discussion\n`);
    sections.push(`Confidence in ETA: ${pbi.confidence_in_eta}`);
    sections.push(`Sprint Ready: ${pbi.recommended_next_actions.sprint_ready ? 'Yes' : 'No'}`);

    if (pbi.recommended_next_actions.can_start) {
      sections.push(`Can Start: ${pbi.recommended_next_actions.can_start}`);
    }

    sections.push('');
    sections.push(`---`);
    sections.push(`Generated by Backlog Chef`);

    return sections.join('\n');
  }

  formatSummary(input: ReadinessAssessmentInput): string {
    const sections: string[] = [];

    sections.push(`BACKLOG READINESS SUMMARY`);
    sections.push(`=`.repeat(60));
    sections.push('');

    // Summary statistics
    sections.push(`Total PBIs: ${input.metadata.total_pbis}`);
    sections.push(`Ready for Sprint: ${input.metadata.ready_count}`);
    sections.push(`Needs Refinement: ${input.metadata.needs_refinement_count}`);
    sections.push(`Not Ready: ${input.metadata.not_ready_count}`);
    sections.push(`Average Score: ${input.metadata.average_readiness_score}/100`);
    sections.push('');

    // PBI List
    sections.push(`PBI LIST:`);
    sections.push('');

    for (const pbi of input.readiness_assessment) {
      const status = this.mapStatusToState(pbi.readiness_status);
      sections.push(`${pbi.pbi_id} | ${status} | ${pbi.readiness_score} | ${pbi.title}`);
    }

    sections.push('');
    sections.push(`Generated: ${new Date(input.metadata.generated_at).toLocaleString()}`);
    sections.push(`Model: ${input.metadata.model_used}`);

    return sections.join('\n');
  }

  getFileExtension(): string {
    return '.txt';
  }

  getName(): string {
    return 'Azure DevOps';
  }

  private mapStatusToState(readinessStatus: string): string {
    if (readinessStatus.includes('READY')) {
      return 'Committed';
    } else if (readinessStatus.includes('NEEDS REFINEMENT')) {
      return 'Approved';
    } else {
      return 'New';
    }
  }

  private calculatePriority(pbi: PBIReadinessAssessment): number {
    const score = parseInt(pbi.readiness_score.split('/')[0]);

    if (score >= 85) {
      return 1; // High priority - ready to go
    } else if (score >= 60) {
      return 2; // Medium priority - needs refinement
    } else {
      return 3; // Low priority - not ready
    }
  }

  private generateTags(pbi: PBIReadinessAssessment): string[] {
    const tags: string[] = [];

    // Add readiness tag
    if (pbi.readiness_status.includes('READY')) {
      tags.push('ready-for-sprint');
    } else if (pbi.readiness_status.includes('NEEDS REFINEMENT')) {
      tags.push('needs-refinement');
    } else {
      tags.push('not-ready');
    }

    // Add blocking tag if there are blockers
    if (pbi.definition_of_ready_checklist.blocking_failures &&
        Object.keys(pbi.definition_of_ready_checklist.blocking_failures).length > 0) {
      tags.push('has-blockers');
    }

    // Add confidence tag
    tags.push(`confidence-${pbi.confidence_in_eta.toLowerCase()}`);

    return tags;
  }

  private formatCriterionName(id: string): string {
    return id
      .split('_')
      .map(word => word.charAt(0).toUpperCase() + word.slice(1))
      .join(' ');
  }
}
